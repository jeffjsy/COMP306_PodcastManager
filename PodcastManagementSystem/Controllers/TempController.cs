using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using PodcastManagementSystem.Interfaces;
using PodcastManagementSystem.Models;
using System;
using System.Linq;
using System.Threading.Tasks;

namespace PodcastManagementSystem.Controllers
{
    [Authorize(Roles = "ListenerViewer, Admin, Podcaster")]
    public class ListenerController : Controller
    {
        private readonly IPodcastRepository _podcastRepo;
        private readonly ICommentRepository _commentRepo;
        private readonly UserManager<ApplicationUser> _userManager;

        public ListenerController(
            IPodcastRepository podcastRepo,
            ICommentRepository commentRepo,
            UserManager<ApplicationUser> userManager)
        {
            _podcastRepo = podcastRepo;
            _commentRepo = commentRepo;
            _userManager = userManager;
        }

        // GET: /Listener/Dashboard
        public async Task<IActionResult> Dashboard(string searchString, string creatorId, string viewType = "all")
        {
            Guid? creatorGuid = null;
            if (!string.IsNullOrWhiteSpace(creatorId) && Guid.TryParse(creatorId, out var parsedGuid))
            {
                creatorGuid = parsedGuid;
            }

            if (!string.IsNullOrWhiteSpace(searchString) || creatorGuid.HasValue)
            {
                var searchResults = await _podcastRepo.SearchEpisodesAsync(searchString, creatorGuid);
                ViewBag.SearchTerm = searchString;
                return View(searchResults);
            }

            return viewType.ToLower() switch
            {
                "popular" => View(await _podcastRepo.GetPopularEpisodesAsync()),
                "recent" => View(await _podcastRepo.GetRecentEpisodesAsync()),
                "all" or _ => View(await _podcastRepo.GetRecentEpisodesAsync()),
            };
        }

        // GET: /Listener/Episode/5
        public async Task<IActionResult> Episode(int id)
        {
            var episode = await _podcastRepo.GetEpisodeDetailsAsync(id);
            if (episode == null)
                return NotFound();

            await _podcastRepo.IncrementPlayCountAsync(id);

            var comments = await _commentRepo.GetCommentsByEpisodeIdAsync(id);
            ViewBag.Comments = comments;

            // Convert UserID to Guid
            var userIdString = _userManager.GetUserId(User);
            Guid userGuid = Guid.Empty;
            if (!string.IsNullOrEmpty(userIdString))
            {
                Guid.TryParse(userIdString, out userGuid);
            }

            ViewBag.IsSubscribed = await _podcastRepo.IsSubscribedAsync(userGuid, episode.PodcastID);
            return View(episode);
        }

        // POST: /Listener/Subscribe/1
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> Subscribe(int podcastId)
        {
            var userIdString = _userManager.GetUserId(User);
            if (string.IsNullOrEmpty(userIdString) || !Guid.TryParse(userIdString, out var userGuid))
                return Unauthorized();

            var success = await _podcastRepo.AddSubscriptionAsync(userGuid, podcastId);

            if (success)
                TempData["Message"] = "Successfully subscribed to the podcast!";
            else
                TempData["Error"] = "You are already subscribed to this podcast.";

            return RedirectToAction(nameof(Episode), new { id = TempData["EpisodeId"] });
        }

        // POST: /Listener/AddComment
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<IActionResult> AddComment(int episodeId, string commentText)
        {
            var userIdString = _userManager.GetUserId(User);
            Guid UserIdGuid = Guid.Parse(userIdString);

            if (string.IsNullOrWhiteSpace(commentText))
            {
                TempData["Error"] = "Comment cannot be empty.";
                return RedirectToAction(nameof(Episode), new { id = episodeId });
            }

            var comment = new Comment
            {
                // CommnetID is generated by database (see Comment model)
                CommentID = Guid.NewGuid(),
                EpisodeID = episodeId,
                UserID = UserIdGuid, // Keep as string if Comment.UserID is string
                Text = commentText,
                TimeStamp = DateTime.UtcNow
            };

            await _commentRepo.AddCommentAsync(comment);
            TempData["Message"] = "Comment added successfully.";

            return RedirectToAction(nameof(Episode), new { id = episodeId });
        }

        // POST: /Listener/EditComment
        [HttpPost]
        [ValidateAntiForgeryToken]
        [Authorize]
        public async Task<IActionResult> EditComment(int commentId, int episodeId, string updatedText)
        {

            if (!Guid.TryParse(commentId.ToString(), out Guid commentGuid))
            {
                TempData["Error"] = "Invalid comment ID format.";
                return RedirectToAction(nameof(Episode), new { episodeId });
            }

            var existingComment = await _commentRepo.GetCommentByIdAsync(episodeId, commentGuid);

            var currentUserIdString = _userManager.GetUserId(User);
            Guid currentUserIdGuid = Guid.Parse(currentUserIdString);

            // --- Validation and Security Checks ---

            // 1. Check if comment exists or if the current user owns it.
            if (existingComment == null || existingComment.UserID != currentUserIdGuid)
            {
                TempData["Error"] = "You are not authorized to edit this comment or it doesn't exist.";
                return RedirectToAction(nameof(Episode), new { episodeId = episodeId });
            }

            // 2. Check the 24-hour time limit.
            if (existingComment.TimeStamp < DateTime.UtcNow.AddHours(-24))
            {
                TempData["Error"] = "Comments can only be edited within 24 hours of posting.";
                return RedirectToAction(nameof(Episode), new { episodeId = episodeId });
            }

            // 3. Check if the updated text is valid
            if (string.IsNullOrWhiteSpace(updatedText) || updatedText.Length > 500)
            {
                TempData["Error"] = "Updated comment cannot be empty or exceed 500 characters.";
                return RedirectToAction(nameof(Episode), new { episodeId = episodeId });
            }

            // Update the comment
            existingComment.Text = updatedText.Trim(); 
            existingComment.TimeStamp = DateTime.UtcNow; 

            await _commentRepo.UpdateCommentAsync(existingComment);

            TempData["SuccessMessage"] = "Comment updated successfully."; 
            return RedirectToAction(nameof(Episode), new { episodeId = episodeId });
        }
    }
}
